import { createSlice, PayloadAction, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

// Define the interface for a Spell object
export interface Spell {
  index: string;
  name: string;
  level: string;
  url: string;
}

// Define the state structure for spells
interface SpellState {
  spells: Spell[]; // Array to store spells
  loading: boolean; // Loading state indicator
  error: string | null; // Error message if any
  selectedSpell: any; // Currently selected spell details
  favorites: Spell[]; // Array to store favorite spells
}

// Initial state for the spells slice
const initialState: SpellState = {
  spells: [],
  loading: false,
  error: null,
  selectedSpell: {},
  favorites: [],
};

// Async thunk to fetch all spells from API
export const fetchSpells = createAsyncThunk(
  "spells/fetchSpells",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get("https://www.dnd5eapi.co/api/spells");
      return response.data.results; // Return array of spells from response
    } catch (error: any) {
      return rejectWithValue(error.response.data); // Return error message on failure
    }
  }
);

// Async thunk to fetch details of a specific spell by its index
export const fetchSpellDetails = createAsyncThunk(
  "spells/fetchSpellDetails",
  async (index: string, { rejectWithValue }) => {
    try {
      const response = await axios.get(
        `https://www.dnd5eapi.co/api/spells/${index}`
      );
      return response.data; // Return detailed spell information
    } catch (error: any) {
      return rejectWithValue(error.response.data); // Return error message on failure
    }
  }
);

// Create a slice for managing spells state, including reducers and extra reducers
const spellSlice = createSlice({
  name: "spells", // Slice name
  initialState, // Initial state defined earlier
  reducers: {
    addFavorite: (state, action: PayloadAction<Spell>) => {
      state.favorites.push(action.payload); // Add spell to favorites array
    },
    removeFavorite: (state, action: PayloadAction<Spell>) => {
      state.favorites = state.favorites.filter(
        (spell) => spell.index !== action.payload.index
      ); // Remove spell from favorites array
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchSpells.pending, (state) => {
        state.loading = true; // Set loading state to true during fetch
        state.error = null; // Clear any previous error
      })
      .addCase(
        fetchSpells.fulfilled,
        (state, action: PayloadAction<Spell[]>) => {
          state.loading = false; // Set loading state to false after fetch
          state.spells = action.payload; // Update spells array with fetched data
        }
      )
      .addCase(fetchSpells.rejected, (state, action: PayloadAction<any>) => {
        state.loading = false; // Set loading state to false on fetch error
        state.error = action.payload; // Set error message with fetch error data
      })
      .addCase(fetchSpellDetails.pending, (state) => {
        state.loading = true; // Set loading state to true during fetch
        state.error = null; // Clear any previous error
      })
      .addCase(
        fetchSpellDetails.fulfilled,
        (state, action: PayloadAction<Spell>) => {
          state.loading = false; // Set loading state to false after fetch
          state.selectedSpell = action.payload; // Update selected spell details
        }
      )
      .addCase(
        fetchSpellDetails.rejected,
        (state, action: PayloadAction<any>) => {
          state.loading = false; // Set loading state to false on fetch error
          state.error = action.payload; // Set error message with fetch error data
        }
      );
  },
});

// Export actions generated by createSlice
export const { addFavorite, removeFavorite } = spellSlice.actions;

// Export default reducer function generated by createSlice
export default spellSlice.reducer;
